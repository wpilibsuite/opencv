import org.gradle.internal.os.OperatingSystem

import java.nio.file.Files
import java.nio.file.Paths;

apply plugin: 'java'

def date = new Date()
def formattedDate = date.format('yyMMdd')
version = "3.1.0"

ext {
    defaultCmakeArgs = [
            '-DBUILD_SHARED_LIBS=OFF',
            '-DWITH_CUDA=OFF',
            '-DWITH_IPP=OFF',
            '-DWITH_OPENCL=OFF',
            '-DWITH_FFMPEG=OFF',
            '-DWITH_OPENEXR=OFF',
            '-DWITH_GSTREAMER=OFF',
            '-DWITH_GTK=OFF',
            '-DWITH_1394=OFF',
            '-DWITH_JASPER=OFF',
            '-DWITH_TIFF=OFF',
            '-DBUILD_JPEG=ON',
            '-DBUILD_PNG=ON',
            '-DBUILD_ZLIB=ON',
            '-DBUILD_TESTS=OFF',
            '-DPython_ADDITIONAL_VERSIONS=3.5',
            '-DWITH_WEBP=OFF'
    ]
}

def getPlatform() {
    def platform
    def os_name = System.getProperty("os.name")
    def os_arch = System.getProperty("os.arch")

    if (os_arch == 'amd64') {
        os_arch = 'x86_64'
    } else if (os_arch == 'i386') {
        os_arch = 'x86'
    }

    if (OperatingSystem.current().isWindows()) {
        platform = "windows-${os_arch}"
    } else if (OperatingSystem.current().isLinux()) {
        platform = "linux-${os_arch}"
    } else if (OperatingSystem.current().isMacOsX()) {
        platform = "osx-${os_arch}"
    } else {
        platform = "${os_name}-${os_arch}"
    }
    return platform
}

def getOutputFormat(platform) {
    if (platform == "linux-armhf") {
        return "elf32-littlearm"
    } else if (platform == "linux-arm") {
        return "elf32-littlearm"
    } else if (platform == "linux-x86") {
        return "elf32-i386"
    } else if (platform == "linux-x86_64") {
        return "elf64-x86-64"
    } else if (platform == "osx-x86") {
        return ""
    } else if (platform == "osx-x86_64") {
        return ""
    } else if (platform == "windows-x86") {
        return "pe-i386"
    } else if (platform == "windows-x86_64") {
        return "pe-x86-64"
    } else {
        return ""
    }
}

// Determine what repo to publish to. Default is development. Valid options are development, beta, stable, and release
if (!hasProperty('repo')) {
    allprojects {
        ext.repo = 'development'
    }
}

if (!hasProperty('platform')) {
    println "No 'platform' property specified; using the build system's platform"
    ext {
        platform = getPlatform()
    }
}

if (!hasProperty('cmakePath')) {
    ext {
        cmakePath = "cmake"
    }
}

println "Building for platform ${project.platform}"

def rootPath = Paths.get(projectDir.canonicalPath)
def cmakeBuildDirectory = rootPath.resolve('build').resolve(project.platform)
def jarName = "${project.name}-${version.replace(".", "").replace("-" + formattedDate, "")}.jar"
def pathToOpenCVJar = cmakeBuildDirectory.resolve("bin").resolve(jarName)

if (project.platform.startsWith('windows')) {
    def gen = "Visual Studio 12 2013"
    if (hasProperty('vsversion')) {
        if (project.vsversion == "2015") {
            gen = "Visual Studio 14 2015"
        }
    }
    if (project.platform == "windows-x86_64") {
        gen += " Win64"
    }
    ext {
        cmakeGenerator = gen
    }
}

repositories {
    mavenLocal()
    mavenCentral()
}

task cmake(type: Exec) {
    if (!Files.exists(cmakeBuildDirectory)) {
        Files.createDirectories(cmakeBuildDirectory)
    }

    def cmakeArgs = {
        def toolchain = null
        if (hasProperty('toolchain')) {
            toolchain = project.toolchain
        }
        if (project.platform == "linux-arm"  && project.hasProperty("armSuffix")) {
            toolchain = "platforms/linux/arm-gnueabihf.toolchain.cmake"
            println "Using toolchain '${toolchain}'"
            return defaultCmakeArgs + "-DCMAKE_TOOLCHAIN_FILE=${toolchain}" +
                '-DENABLE_NEON=ON' +
                '-DENABLE_VFPV3=ON'
        }
        if (project.platform == "linux-arm") {
            toolchain = "platforms/linux/arm-gnueabi.toolchain.cmake"
            println "Using toolchain '${toolchain}'"
            return defaultCmakeArgs + "-DCMAKE_TOOLCHAIN_FILE=${toolchain}" +
                '-DBUILD_SHARED_LIBS=ON' +
                '-DENABLE_NEON=ON' +
                '-DENABLE_VFPV3=ON' +
                '-DSOFTFP=ON'
        }

        if (toolchain) {
            println "Using toolchain '${toolchain}'"
            return defaultCmakeArgs + "-DCMAKE_TOOLCHAIN_FILE=${toolchain}"
        } else {
            println "No toolchain specified"
            return defaultCmakeArgs
        }
    }

    workingDir cmakeBuildDirectory.toString()

    if (project.platform.startsWith("windows")) {
        executable project.cmakePath
        args = cmakeArgs() + ['-G', '"' + project.cmakeGenerator + '"', rootPath]
    } else {
        executable project.cmakePath
        args = cmakeArgs() + [rootPath]
    }
}

task make(type: Exec, dependsOn: cmake) {
    workingDir cmakeBuildDirectory.toString()
    def processors = Runtime.runtime.availableProcessors()

    if (project.platform.startsWith("windows")) {
        executable 'cmd'
        args = ['/c', 'msbuild', '/m', 'OpenCV.sln', '/t:Build', '/p:Configuration=Release', '/v:m']
    } else {
        executable 'make'
        args = ["-j${processors}"]
    }

    outputs.file pathToOpenCVJar.toFile()
    outputs.file cmakeBuildDirectory.resolve("src").toFile()
}

if (project.platform.startsWith('windows')) {
    task nativeLibLinks(type: Exec, dependsOn: make) {
        workingDir cmakeBuildDirectory.resolve("lib").resolve("Release").toString()
        executable 'lib'
        args = ['/OUT:opencv.lib', "opencv_calib3d310.lib", "opencv_features2d310.lib", "opencv_flann310.lib", "opencv_highgui310.lib", "opencv_imgcodecs310.lib", "opencv_imgproc310.lib", "opencv_ml310.lib", "opencv_objdetect310.lib", "opencv_photo310.lib", "opencv_shape310.lib", "opencv_stitching310.lib", "opencv_superres310.lib", "opencv_videoio310.lib", "opencv_video310.lib", "opencv_videostab310.lib", "opencv_core310.lib", "../../3rdparty/lib/Release/libjpeg.lib", "../../3rdparty/lib/Release/libpng.lib", "../../3rdparty/lib/Release/zlib.lib"]
    }
} else {
    task nativeLibLinks(type: Exec, dependsOn: make) {
        workingDir cmakeBuildDirectory.resolve("lib").toString()

        if (OperatingSystem.current().isWindows()) {
            executable 'cmd'
            args = ['/c', "$rootPath/platforms/linux/genlinks.bat", getOutputFormat(project.platform)]
        } else {
            executable "$rootPath/platforms/linux/genlinks"
            args = [getOutputFormat(project.platform)]
        }

        doLast {
            def outputFormat = getOutputFormat(project.platform)
            def soFile = file("$cmakeBuildDirectory/lib/libopencv.so")
            soFile.write "OUTPUT_FORMAT($outputFormat)\nGROUP ( AS_NEEDED ( -lopencv_calib3d -lopencv_features2d -lopencv_flann -lopencv_highgui -lopencv_imgcodecs -lopencv_imgproc -lopencv_ml -lopencv_objdetect -lopencv_photo -lopencv_shape -lopencv_stitching -lopencv_superres -lopencv_videoio -lopencv_video -lopencv_videostab -lopencv_core -llibjpeg -llibpng -lzlib ) )\n"
        }
    }
}

task openCVJniJar(type: Jar, dependsOn: make) {
    baseName = "${project.name}-jni"
    def platformName
    if (project.platform =="linux-arm" && project.hasProperty("armSuffix")) {
        platformName = "${project.platform}${project.armSuffix}"
        classifier = platformName
    } else {
        platformName = "${project.platform}"
        classifier = platformName
    }

    manifest {
        attributes(
                "Created-By": "WPILib Gradle Build Script",
                "Implementation-Title": "OpenCV JNI Library, ${platformName}",
                "Implementation-Version": project.version,
                "Implementation-Vendor": "Itseez",

                "Bundle-Name": "${baseName}",
                "Bundle-Version": project.version,
                "Bundle-License": "https://opensource.org/licenses/BSD-3-Clause",
                "Bundle-Vendor": "WPILib")
    }

    if (!project.platform.startsWith("windows")) {
        from(cmakeBuildDirectory.resolve("lib").toFile()) {
            include '*java*.so'
            include '*java*.dylib'
        }
    } else {
        from(cmakeBuildDirectory.resolve("bin").resolve("Release").toFile()) {
            include '*java*.dll'
        }
    }
}

task openCVNativeLibJar(type: Jar, dependsOn: nativeLibLinks) {
    baseName = "${project.name}-natives"
    def platformName
    if (project.platform =="linux-arm" && project.hasProperty("armSuffix")) {
        platformName = "${project.platform}${project.armSuffix}"
        classifier = platformName
    } else {
        platformName = "${project.platform}"
        classifier = platformName
    }
    manifest {
        attributes(
                "Created-By": "WPILib Gradle Build Script",
                "Implementation-Title": "OpenCV Native Libraries, ${platformName}",
                "Implementation-Version": project.version,
                "Implementation-Vendor": "Itseez",

                "Bundle-Name": "${baseName}",
                "Bundle-Version": project.version,
                "Bundle-License": "https://opensource.org/licenses/BSD-3-Clause",
                "Bundle-Vendor": "WPILib")
    }

    if (!project.platform.startsWith("windows")) {
        from(cmakeBuildDirectory.resolve("lib").toFile()) {
            exclude '*java*.so'
            exclude '*java*.dylib'
            exclude '**/*dephelp*'
        }
    } else {
        from(cmakeBuildDirectory.resolve("lib").resolve("Release").toFile()) {
            include 'opencv.lib' // static lib
            include '*.dll' // dynamic lib
            exclude '*java*'
        }
    }
    from(cmakeBuildDirectory.resolve("3rdparty").resolve("lib").toFile())
}

task openCVJar(type: Jar, dependsOn: make) {
    baseName = "${project.name}-java"
    manifest {
        attributes(
                "Created-By": "WPILib Gradle Build Script",
                "Implementation-Title": "OpenCV",
                "Implementation-Version": project.version,
                "Implementation-Vendor": "Itseez",

                "Bundle-Name": project.name,
                "Bundle-Version": project.version,
                "Bundle-License": "https://opensource.org/licenses/BSD-3-Clause",
                "Bundle-Vendor": "WPILib")
    }

    from { zipTree(pathToOpenCVJar.toFile()) } {
        exclude "META-INF/*"
        exclude "META-INF"
    }
}

task openCVSourceJar(type: Jar, dependsOn: make) {
    baseName = "${project.name}-sources"
    manifest {
        attributes(
                "Created-By": "WPILib Gradle Build Script",
                "Implementation-Title": "OpenCV Java Sources",
                "Implementation-Version": project.version,
                "Implementation-Vendor": "Itseez",

                "Bundle-Name": "${project.name}-sources",
                "Bundle-Version": project.version,
                "Bundle-License": "https://opensource.org/licenses/BSD-3-Clause",
                "Bundle-Vendor": "WPILib")
    }

    from(cmakeBuildDirectory.resolve("src").toFile()) {
        include '**/*.java'
    }
}

task openCVHeadersJar(type: Jar, dependsOn: make) {
    baseName = "${project.name}-headers"
    manifest {
        attributes(
                "Created-By": "WPILib Gradle Build Script",
                "Implementation-Title": "OpenCV C++ Headers",
                "Implementation-Version": project.version,
                "Implementation-Vendor": "Itseez",

                "Bundle-Name": "${project.name}-headers",
                "Bundle-Version": project.version,
                "Bundle-License": "https://opensource.org/licenses/BSD-3-Clause",
                "Bundle-Vendor": "WPILib")
    }
    from(rootPath.resolve('modules').toFile()) {
        include '*/include/**/*.hpp'
        include '*/include/**/*.h'
        exclude 'java/**'
        exclude 'python/**'
        eachFile { FileCopyDetails fcp ->
            fcp.relativePath = new RelativePath(!fcp.file.isDirectory(), fcp.relativePath.segments[2..-1] as String[])
        }
    }
    includeEmptyDirs = false
}

task allArtifacts(type: GradleBuild) {
    tasks = ['openCVJar', 'openCVSourceJar', 'openCVJniJar', 'openCVNativeLibJar', 'openCVHeadersJar']
}

apply plugin: 'maven-publish'
publishing {
    publications {
        java(MavenPublication) {
            groupId 'org.opencv'
            artifactId "${project.name}-java"
            artifact openCVJar
            artifact openCVSourceJar {
                classifier 'sources'
            }

            pom.withXml {
                def licenseNode = asNode().appendNode('licenses').appendNode('license')
                licenseNode.appendNode('name', 'BSD 3-Clause License')
                licenseNode.appendNode('url', 'https://opensource.org/licenses/BSD-3-Clause')
            }
        }
        jni(MavenPublication) {
            groupId 'org.opencv'
            artifactId "${project.name}-jni"
            artifact openCVJniJar

            pom.withXml {
                def licenseNode = asNode().appendNode('licenses').appendNode('license')
                licenseNode.appendNode('name', 'BSD 3-Clause License')
                licenseNode.appendNode('url', 'https://opensource.org/licenses/BSD-3-Clause')
            }
        }
        headers(MavenPublication) {
            groupId 'org.opencv'
            artifactId "${project.name}-headers"
            artifact openCVHeadersJar

            pom.withXml {
                def licenseNode = asNode().appendNode('licenses').appendNode('license')
                licenseNode.appendNode('name', 'BSD 3-Clause License')
                licenseNode.appendNode('url', 'https://opensource.org/licenses/BSD-3-Clause')
            }
        }
        natives(MavenPublication) {
            groupId 'org.opencv'
            artifactId "${project.name}-natives"
            artifact openCVNativeLibJar

            pom.withXml {
                def licenseNode = asNode().appendNode('licenses').appendNode('license')
                licenseNode.appendNode('name', 'BSD 3-Clause License')
                licenseNode.appendNode('url', 'https://opensource.org/licenses/BSD-3-Clause')
            }
        }
    }
    repositories {
        maven {
            url "${System.getProperty('user.home')}/releases/maven/${project.repo}"
        }
    }
}
